#include <iostream>

using namespace std;

/*
Задаёт виды создаваемых объектов с помощью экземпляра-прототипа и создаёт новые объекты путём копирования этого прототипа.
Он позволяет уйти от реализации и позволяет следовать принципу «программирование через интерфейсы».
В качестве возвращающего типа указывается интерфейс/абстрактный класс на вершине иерархии, а классы-наследники могут подставить туда наследника, реализующего этот тип.

Проще говоря, это паттерн создания объекта через клонирование другого объекта вместо создания через конструктор.

Паттерн используется чтобы:

Избежать дополнительных усилий по созданию объекта стандартным путём (имеется в виду использование конструктора,
так как в этом случае также будут вызваны конструкторы всей иерархии предков объекта), когда это непозволительно дорого для приложения.
Избежать наследования создателя объекта (object creator) в клиентском приложении, как это делает паттерн abstract factory.

Используйте этот шаблон проектирования, когда системe безразлично как именно в ней создаются, компонуются и представляются продукты:

Инстанцируемые классы определяются во время выполнения, например с помощью динамической загрузки;
Избежать построения иерархий классов или фабрик, параллельных иерархии классов продуктов;
Экземпляры класса могут находиться в одном из нескольких различных состояний.
Может оказаться удобнее установить соответствующее число прототипов и клонировать их, а не инстанцировать каждый раз класс вручную в подходящем состоянии.

*/

class Meal {
public:
    virtual ~Meal();
    virtual void eat() = 0;
    virtual Meal *clone() const = 0;
    //...
};
class Spaghetti : public Meal {
public:
    Spaghetti( const Spaghetti &);
    void eat();
    Spaghetti *clone() const { return new Spaghetti( *this ); }
    //...
};

int main()
{
    cout << "Hello World!" << endl;
    return 0;
}
