Назначение паттерна Decorator
Паттерн Decorator динамически добавляет новые обязанности объекту. Декораторы являются гибкой альтернативой порождению подклассов для расширения функциональности.
Рекурсивно декорирует основной объект.
Паттерн Decorator использует схему "обертываем подарок, кладем его в коробку, обертываем коробку".

Решаемая проблема
Вы хотите добавить новые обязанности в поведении или состоянии отдельных объектов во время выполнения программы. Использование наследования не представляется возможным, поскольку это решение статическое и распространяется целиком на весь класс.

Использование паттерна Decorator
Подготовьте исходные данные: один основной компонент и несколько дополнительных (необязательных) "оберток".
Создайте общий для всех классов интерфейс по принципу "наименьшего общего знаменателя НОЗ" (lowest common denominator LCD). Этот интерфейс должен делать все классы взаимозаменяемыми.
Создайте базовый класс второго уровня (Decorator) для поддержки дополнительных декорирующих классов.
Основной класс и класс Decorator наследуют общий НОЗ-интерфейс.
Класс Decorator использует отношение композиции. Указатель на НОЗ-объект инициализируется в конструкторе.
Класс Decorator делегирует выполнение операции НОЗ-объекту.
Для реализации каждой дополнительной функциональности создайте класс, производный от Decorator.
Подкласс Decorator реализует дополнительную функциональность и делегирует выполнение операции базовому классу Decorator.
Клиент несет ответственность за конфигурирование системы: устанавливает типы и последовательность использования основного объекта и декораторов.

Особенности паттерна Decorator
Adapter придает своему объекту новый интерфейс, Proxy предоставляет тот же интерфейс, а Decorator обеспечивает расширенный интерфейс.
Adapter изменяет интерфейс объекта. Decorator расширяет ответственность объекта. Decorator, таким образом, более прозрачен для клиента. Как следствие, Decorator поддерживает рекурсивную композицию, что невозможно с чистыми адаптерами.
Decorator можно рассматривать как вырожденный случай Composite с единственным компонентом. Однако Decorator добавляет новые обязанности и не предназначен для агрегирования объектов.
Decorator позволяет добавлять новые функции к объектам без наследования. Composite фокусирует внимание на представлении, а не декорировании. Эти характеристики являются различными, но взаимодополняющими, поэтому Composite и Decorator часто используются вместе.
Decorator и Proxy имеют разное назначение, но схожие структуры. Их реализации хранят ссылку на объект, которому они отправляют запросы.
Decorator позволяет изменить внешний облик объекта, Strategy – его внутреннее содержание.

Паттерн проектирования Decorator по шагам
Создайте "наименьший общий знаменатель", делающий классы взаимозаменяемыми.
Создайте базовый класс второго уровня для реализации дополнительной функциональности.
Основной класс и класс-декоратор используют отношение "является".
Класс-декоратор "имеет" экземпляр "наименьшего общего знаменателя".
Класс Decorator делегирует выполнение операции объекту "имеет".
Для реализации каждой дополнительной функциональности создайте подклассы Decorator.
Подклассы Decorator делегируют выполнение операции базовому классу и реализуют дополнительную функциональность.
Клиент несет ответственность за конфигурирование нужной функциональности.

Замечания и комментарии
Хотя объект-декоратор может добавлять свою функциональность до или после функциональности основного объекта, цепочка создаваемых объектов всегда должна заканчиваться объектом класса ConcreteComponent.
Базовые классы языка Java широко используют шаблон Декоратор для организации обработки операций ввода-вывода.
И декоратор, и адаптер являются обёртками вокруг объекта — хранят в себе ссылку на оборачиваемый объект и часто передают в него вызовы методов. Отличие декоратора от адаптера в том, что адаптер имеет внешний интерфейс, отличный от интерфейса оборачиваемого объекта, и используется именно для стыковки разных интерфейсов. Декоратор же имеет точно такой же интерфейс, и используется для добавления функциональности.
Для расширения функциональности класса возможно использовать как декораторы, так и стратегии. Декораторы оборачивают объект снаружи, стратегии же вставляются в него внутрь по неким интерфейсам.
Недостаток стратегии: класс должен быть спроектирован с возможностью вставления стратегий, декоратор же не требует такой поддержки.
Недостаток декоратора: он оборачивает ровно тот же интерфейс, что предназначен для внешнего мира, что вызывает смешение публичного интерфейса и интерфейса кастомизации, которое не всегда желательно.