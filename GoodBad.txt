Назначение паттерна Chain of Responsibility
Паттерн Chain of Responsibility позволяет избежать жесткой зависимости отправителя запроса от его получателя, при этом запрос может быть обработан несколькими объектами. Объекты-получатели связываются в цепочку. Запрос передается по этой цепочке, пока не будет обработан.
Вводит конвейерную обработку для запроса с множеством возможных обработчиков.
Объектно-ориентированный связанный список с рекурсивным обходом.

Решаемая проблема
Имеется поток запросов и переменное число "обработчиков" этих запросов. Необходимо эффективно обрабатывать запросы без жесткой привязки к их обработчикам, при этом запрос может быть обработан любым обработчиком.

Пример паттерна Chain of Responsibility
Паттерн Chain of Responsibility позволяет избежать привязки отправителя запроса к его получателю, давая шанс обработать запрос нескольким получателям. Банкомат использует Chain of Responsibility в механизме выдачи денег.

Использование паттерна Chain of Responsibility
Базовый класс имеет указатель на "следующий обработчик".
Каждый производный класс реализует свой вклад в обработку запроса.
Если запрос должен быть "передан дальше", то производный класс "вызывает" базовый класс, который с помощью указателя делегирует запрос далее.
Клиент (или третья сторона) создает цепочку получателей (которая может иметь ссылку с последнего узла на корневой узел).
Клиент передает каждый запрос в начало цепочки.
Рекурсивное делегирование создает иллюзию волшебства.

Особенности паттерна Chain of Responsibility
Паттерны Chain of Responsibility, Command, Mediator и Observer показывают, как можно разделить отправителей и получателей с учетом их особенностей. Chain of Responsibility передает запрос отправителя по цепочке потенциальных получателей.
Chain of Responsibility может использовать Command для представления запросов в виде объектов.
Chain of Responsibility часто применяется вместе с паттерном Composite. Родитель компонента может выступать в качестве его преемника.