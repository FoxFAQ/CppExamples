«Upside-Down Inheritance» (перевёрнутое наследование) из-за того, что она позволяет расширять иерархию классов за счёт подстановки других базовых классов.

В примере выше, функция Base<Derived>::interface() известна компилятору, хотя и объявлена перед объявлением структуры struct Derived. 
Тем не менее, эта функция не инстанцируется до момента фактического вызова, который должен произойти после объявления Derived.

Это приём позволяет достичь эффекта, похожего на использование виртуальных функций без использования динамического полиморфизма. 
В этом смысле эта идиома используется в библиотеках Windows ATL и WTL..

Развивая предыдущий пример, предположим, что есть базовый класс вообще без виртуальных методов. Это значит, 
что вызов любого метода базового класса изнутри базового класса приведёт к вызову метода именно этого базового класса, 
даже если он был переопределён в классе-наследнике. Например, если наследник вызывает непереопределенный метод базового класса, 
который, в свою очередь, вызывает другой метод базового класса, уже переопределённый наследником, то будет вызван не метод наследника, а метод базового класса.

Однако, если методы базового класса используют CRTP для вызовов других методов, то переопределённые функции будут выбраны во время компиляции. 
Это эффективно эмулирует систему виртуальных функций во время компиляции без необходимости платить цену за динамический полиморфизм 
(таблицы виртуальных методов, время, затрачиваемое на выбор метода, множественное наследование), но не позволяет делать этого во время выполнения.